/* -*- Mode: Prolog -*- */

:- module(lp_writer,
          [
           export_logicprogram/2
           ]).

:- use_module(cl_io).

:- multifile cl_io:serialize_cltext_hook/4.
cl_io:serialize_cltext_hook(_File,logicprogram,Text,Opts) :-
        export_logicprogram(Text,Opts).

export_logicprogram(Text,Opts) :-
        select(goals(Goal),Opts,Opts2),
        !,
        export_logicprogram(Text,sos,Opts2),
        export_logicprogram(Goal,goals,Opts2).

% special code - use hook?
export_logicprogram(cltext(L),Opts) :-
        select(comment(test,Goal),L,L2),
        !,
        export_logicprogram(cltext(L2),normal,Opts),
        export_logicprogram(Goal,goals,Opts).

export_logicprogram(Text,Opts) :-
        export_logicprogram(Text,normal,Opts).


export_logicprogram(Text,goals,Opts) :-
        % TODO
        write_lp(Text,Opts).

export_logicprogram(Text,_,Opts) :-
        write_comment('Automatically generated by cltools'),
        write_lp(Text,Opts).

write_comment(A):-
        format('% ~w~n',[A]).

write_lp(A,Toks,_) :-
        cltext(A,Toks,[]),
        concat_atom(Toks,S),
        write(S),
        nl.

jop(and).
jop(or).

nl --> ['\n'].
dot --> ['.\n'].

clcomment(Fmt,X) --> ['% '],{sformat(A,Fmt,X)},[A],nl.  % TODO - newlines
clcomment(X) --> ['% '],{sformat(A,'~q',[X])},[A],nl.  % TODO - newlines

cltext([]) --> !.
cltext([H|L]) --> !,cltext(H),cltext(L).

cltext(module(X,_Y,Text)) --> !,clcomment('Module ~w',[X]),cltext(Text). % TODO
cltext(cltext(Text)) --> !,cltext(Text).
cltext(namedtext(X,Text)) --> !,clcomment(X),cltext(Text).
cltext(comment(X,Text)) --> !,clcomment(X),cltext(Text).
cltext(X) --> axiom([],X).

% quantified sentences
axiom(BoundList,forall(X,Y)) --> !,{append(X,BoundList,NewBoundList)},brac(NewBoundList,Y),dot.
axiom(BoundList,exists(X,Y)) --> !. % TODO
axiom(BoundList,X) --> exprs(BoundList,X),dot.

brac(BoundList,X) --> !,['('],exprs(BoundList,X),[')'].

exprs(_BoundList,[]) --> !.
exprs(BoundList,[H|L]) --> !,exprs(BoundList,H),exprs(BoundList,L).

exprs(BoundList,iff(X,Y)) --> !,exprs(BoundList,if(X,Y)),exprs(BoundList,if(Y,X)).
exprs(BoundList,if(X,Y)) --> !,exprs(BoundList,Y),[' :- '],exprs(BoundList,X).
exprs(BoundList,'='(X,Y)) --> !,['('],exprs(BoundList,X),[' = '],exprs(BoundList,Y),[')'].
exprs(BoundList,not(X)) --> !,['\+'],brac(BoundList,X).
exprs(BoundList,X) --> {X=..[Op|L],jop(Op)},!,exprj(BoundList,Op,L).
exprs(BoundList,X) --> {compound(X),X=..[P|L]},!,predsym(P,L),['('],exprj(BoundList,',',L),[')'].
exprs(BoundList,X) --> {member(X,BoundList),var_lp(X,V)},!,[V].
exprs(_BoundList,X) --> {safe_atom(X,A)},!,[A].

exprs(BoundList,[H]) --> !,exprs(BoundList,H).
exprs(BoundList,[H|T]) --> exprs(BoundList,H),[','],!,exprs(BoundList,T).

varx(Q,L) --> {is_list(L)},!,vars(Q,L).
varx(Q,X) --> {X=..L},!,vars(Q,L). % vars get parsed as terms..
vars(_,[]) --> [].
vars(Q,[H|T]) --> [' ',Q,' '],{var_lp(H,V)},[V],vars(Q,T).

predsym(P,_) --> [P].

exprj(BoundList,_Op,[H]) --> !,exprs(BoundList,H).
exprj(BoundList,Op,[H|T]) --> !,exprs(BoundList,H),opx(Op),exprj(BoundList,Op,T).

opx(and) --> [', '].
opx(or) --> ['; '].
opx(',') --> [', '].

var_lp(A,V):-
        atom_concat('?',A1,A),
        !,
        var_lp(A1,V).

var_lp(A,V):-
        sub_atom(A,0,1,_,Ch),
        (   Ch @>= 'A',
            Ch @=< 'Z'
        ->  V=A
        ;   upcase_atom(A,V)).

safe_atom(A,A):-
        atom_chars(A,[C1|L]),
        C1 @>= 'a',
        C1 @=< 'z',
        forall(member(C,L),
               safe_char(C)),
        !.

safe_atom(A,Safe):-
        concat_atom(Toks,'\'',A),
        concat_atom(Toks,'\\\'',A2),
        sformat(Safe,'\'~w\'',[A2]).
        
safe_char(C):- is_alpha(C).
safe_char('_').
safe_char(C):- C @>= '0', C @=< '9'.


